ALTER SESSION SET nls_date_format='dd-mm-yyyy hh24:mi:ss';

ALTER SYSTEM SET JOB_QUEUE_PROCESSES = 5;

create table main_table(
  id INTEGER generated by default as identity,
  name nvarchar2(100)
);

create table copy_table(
  id INTEGER generated by default as identity,
  name nvarchar2(100)
);

create table journal_table(
  datetime date,
  info nvarchar2(10),
  timeinfo timestamp
);

drop table main_table;
drop table copy_table;
drop table journal_table;
commit;

declare
  i number := 1;
  temp varchar(100);
begin
  loop
    temp := CONCAT('Value ', to_char(i));
    insert into main_table (name) values (temp);
    i := i + 1;
  exit when i > 100;
  end loop;
end;

select * from main_table;
select * from copy_table;
rollback;

----
CREATE OR REPLACE PACKAGE jobs_pack as
  procedure manipulate;
  procedure start_job;
  function is_finished return boolean;
  function is_running return boolean;
  procedure stop_job;
  procedure set_new_date(newDate date);
  procedure delete_job;
END jobs_pack;
-----
CREATE OR REPLACE PACKAGE BODY jobs_pack as
--------------------------------------------
  procedure manipulate
  as
  begin
    insert into copy_table select * from main_table where rownum <= 25 ;
    delete main_table where rownum <= 25;
    insert into journal_table(datetime, info, timeinfo)
    values (sysdate, 'GOOD', current_timestamp);
    commit;
    exception when others then 
    insert into journal_table(datetime, info, timeinfo) values (sysdate, 'ERROR', current_timestamp);
  end manipulate;
---------------------------------------------
  procedure start_job
  as
  begin
    dbms_job.ISUBMIT(job => 1,
                      what => 'begin jobs_pack.manipulate; end;',
                      next_date => sysdate,
                      interval =>'trunc(sysdate + 7) + 60/86400');
    commit;
    dbms_output.put_line('start job');
    exception when others then dbms_output.put_line(sqlerrm);
  end start_job;
---------------------------------------------
  function is_finished return boolean
    is
    temp nvarchar2(10) := 'false';
    BEGIN
      SELECT 'true' INTO temp FROM DUAL WHERE EXISTS (SELECT * FROM USER_JOBS WHERE JOB=1 AND LAST_DATE IS NOT NULL);
      if temp = 'true' then
        return true;
      else
        return false;
      end if;
    EXCEPTION WHEN OTHERS
      THEN RETURN FALSE;
  end is_finished;
----------------------------------------------
  function is_running return boolean
  is
  temp nvarchar2(10) := 'false';
  begin
    SELECT 'true' INTO temp FROM DUAL WHERE EXISTS (SELECT * FROM USER_JOBS WHERE JOB=1 AND USER_JOBS.BROKEN='N');
        if temp = 'true' then
          return true;
        else
          return false;
        end if;
    EXCEPTION WHEN OTHERS
      THEN RETURN FALSE;
  end is_running;
---------------------------------------------
  procedure stop_job
  as
  begin
    DBMS_JOB.BROKEN(1, TRUE);
    COMMIT;
  end stop_job;
----------------------------------------------
  procedure set_new_date(newDate date)
  as
  begin
    DBMS_JOB.CHANGE(  job => 1,
                        what => 'begin jobs_pack.manipulate; end;',
                        next_date => newDate,
                        interval =>'trunc(sysdate + 7) + 60/86400');
    DBMS_JOB.RUN(1);
    commit;
  end set_new_date;
---------------------------------------------
  procedure delete_job
  as
  begin
    dbms_job.remove(1);
    commit;
  end delete_job;
----------------------------------------------
END jobs_pack;
------
exec jobs_pack.start_job;


declare
temp boolean;
temp2 boolean;
begin
  temp := jobs_pack.is_finished;
  temp2 := jobs_pack.is_running;
  if temp = true then 
    dbms_output.put_line('done');
  else
    dbms_output.put_line('in process');
  end if;
  if temp2 = true then 
    dbms_output.put_line('not broken');
  else
    dbms_output.put_line('broken');
  end if;
end; 

begin jobs_pack.stop_job; end;
begin jobs_pack.set_new_date('06.01.2021'); end;
begin jobs_pack.delete_job; end;

select * from user_jobs;
select * from main_table;
select * from copy_table;
select * from journal_table;

----
CREATE OR REPLACE PACKAGE shed_pack as
  procedure s_manipulate;
  procedure s_start_job;
  function s_is_finished return boolean;
  function s_is_running return boolean;
  procedure s_stop_job;
  procedure s_delete_job;
END shed_pack;
-----
CREATE OR REPLACE PACKAGE BODY shed_pack as
--------------------------------------------
  procedure s_manipulate
  as
  begin
    insert into copy_table select * from main_table where rownum <= 30 ;
    delete main_table where rownum <= 30;
    insert into journal_table(datetime, info, timeinfo)
    values (sysdate, 'GOOD', current_timestamp);
    commit;
    exception when others then 
    insert into journal_table(datetime, info, timeinfo) values (sysdate, 'ERROR', current_timestamp);
  end s_manipulate;
--------------------------------------------
  procedure s_start_job
  as
  begin
  DBMS_SCHEDULER.create_job (
    job_name        => 'TEST_MANIP',
    job_type        => 'PLSQL_BLOCK',
    job_action      => 'BEGIN shed_pack.s_manipulate; END;',
    start_date      => SYSTIMESTAMP,
    repeat_interval => 'freq=MINUTELY;INTERVAL=3',
    end_date        => NULL,
    enabled         => TRUE);
    commit;
    dbms_output.put_line('start job');
  exception when others then
    dbms_output.put_line(sqlerrm);
  end s_start_job;
--------------------------------------------
  function s_is_finished return boolean
  is
  temp nvarchar2(10) := 'false';
  begin
  SELECT 'true' INTO temp FROM DUAL WHERE EXISTS (SELECT * FROM all_scheduler_jobs where job_name = 'TEST_MANIP' AND RUN_COUNT>0);
      if temp = 'true' then
        return true;
      else
        return false;
      end if;
  EXCEPTION WHEN OTHERS
    THEN RETURN FALSE;
  end s_is_finished;
--------------------------------------------
  function s_is_running return boolean
  is
  temp nvarchar2(10) := 'false';
  begin
  SELECT 'true' INTO temp FROM DUAL WHERE EXISTS (SELECT * FROM all_scheduler_jobs where job_name = 'TEST_MANIP' AND ENABLED='TRUE');
      if temp = 'true' then
        return true;
      else
        return false;
      end if;
  EXCEPTION WHEN OTHERS
     THEN RETURN FALSE;
  end s_is_running;
-------------------------------------------
  procedure s_stop_job
  is
  begin
    DBMS_SCHEDULER.disable('TEST_MANIP');
    COMMIT;
  end s_stop_job;
-------------------------------------------
procedure s_delete_job
is
begin
DBMS_SCHEDULER.DROP_JOB (job_name => 'TEST_MANIP');
commit;
end s_delete_job;
-------------------------------------------
END shed_pack;
-----------
exec shed_pack.s_start_job;

SELECT * FROM dba_scheduler_jobs where job_name = 'TEST_MANIP';
declare
temp boolean;
temp2 boolean;
begin
  temp := shed_pack.s_is_finished;
  temp2 := shed_pack.s_is_running;
  if temp = true then 
    dbms_output.put_line('done');
  else
    dbms_output.put_line('in process');
  end if;
  if temp2 = true then 
    dbms_output.put_line('not broken');
  else
    dbms_output.put_line('broken');
  end if;
end; 


select * from main_table;
select * from copy_table;
select * from journal_table;

begin shed_pack.s_stop_job; end;

begin shed_pack.s_delete_job; end;